1) Toda operación comienza con la creación de un Contrato de Canje, en el cual se especifica una deuda a pagar en granos,
 y el nombre del productor que está realizando la operación.
Luego, a medida que va cultivando, el productor envía el grano en camiones hacia la empresa, 
y realiza descargas de este grano hasta cubrir la totalidad de su deuda.
Es común que se hagan varias descargas hasta completar un contrato.
El contrato tiene siempre una deuda pendiente abierta, que es la diferencia entre el grano pactado y 
lo que ya ha sido descargado, la cual puede ser consultada por el productor en cualquier momento.


Class Contrato{
 	productor;
	monto;
	//TODO: esto no lo estas usando 
	descargas;
	
	//TODO: Trataria de evitar estos metodos que pisan valores iniciales, porque si bien te estas quedando con el valor que le deben, perdes por cuanto se firmo originalmente el contrato. O que descargas se aplicaron. Fijate que encima hay un requerimiento que te pide saber el estado del contrato en cierto momento, entonces si vos no tenes el valor original ni las descargas probablemente no puedas volver al pasado. 
	descargaAceptada(descarga){
   	    monto = monto - descarga.getMonto();
	}
}

2)Cuando una descarga es realizada, se cargan sus datos (el productor y la cantidad de grano) y 
se la marca como En revisión. Más tarde, especialistas agregan un porcentaje de rendimiento de ese grano, 
que es lo que efectivamente se descontará de la deuda. Una vez que un especialista la marca como Lista,
el dato del rendimiento no puede ser alterado más.

Poder crear una descarga para una cantidad de grano de un productor. Una vez creada, 
la descarga es visualizable pero no editable, salvo el rendimiento,
Marcar una descarga como lista, bloqueando la edición del rendimiento.

Class Descarga{
	productor;
	monto;
	revision;
	estado = new EnRevision(this)
	porcentaje;
	repo = repoContratos

	setEstado(estado) { 
	   //TODO: ojo que no tenes ninguna validacion acá, no solo porque le podrías cambiar el estado, sino que tal vez notificas en un estado incorrecto.
	   this.estado = estado;
	   //TODO esto en realidad se hace en otro modulo (comentario del mail)
	   // faltan notificaciones
	   repo.obtenerContratoDisponible(productor,monto).descargaAceptada(descarga);  
	}
   
        //TODO falta el metodo que delega en el estado
 
	setPorcentaje(porcentaje)

	getMontoFinal() { return monto*porcentaje/100 }
}


Interface Estado{
 	cambiarPorcentaje()
}

EnRevision implements Estado{
	Descarga
	cambiarPorcentaje(porcentaje){
	   descarga.setPorcentaje(porcentaje);
	}
	//TODO quien llama a esto?
	marcarComoLista(){ Descarga.setEstado(new Lista) }
}

Lista implements Estado { 
        //TODO falta implemnetar el marcar como lista?
	cambiarPorcentaje{ throw Exception}                           
}




3) el sistema debe permitir crear un contrato para un productor por una determinada cantidad de grano, 
y al marcarse una descarga como Lista, debe ser capaz de descontar el valor correspondiente a esta del saldo del mismo.
 Una descarga de un productor puede aplicar a cualquier contrato de ese productor.

Class RepoContratos{
	contratos;
	
	obtenerContratoDisponible(productor,monto) { 
		//TODO: c.getMonto >= descarga.getMontoFinal()
		// esto no esta explicito en este ejercicio, pero en realidad si lo quisieras hacer completo deberías ir llenando de a poco los contratos, o sea,
		// podría llenar a uno y si le sobra seguir llenando otro contrato
		contratos.filter(c->c.getProductor == decarga.getProductor() and c.getMonto >= descarga.getMontoFinal()).get(0)
        }
}

Class Contrato{
 	productor;
	monto;
	descargas;
	
	descargaAceptada(descarga){
	   monto = monto - descarga.getMontoFinal();
	}
}



4)Crear un contrato implica determinar la deuda inicial en granos, el productor y el grano que se descargará.
 Un contrato está, además, compuesto por una serie de cláusulas.


Class Contrato{
 	productor;
	monto;
	descargas;
	//TODO faltan las clausulas especificas del tipo de grano.
	clausulas;
	
	
	descargaAceptada(descarga){
	monto = monto - descarga.getMontoFinal();
	}
}

5)Otro detalle a tener en cuenta es que cuando un empleado de Monsaint crea un contrato, primero debe 
guardarlo como borrador, hasta que éste chequea la situación crediticia del productor y recién entonces se crea 
el contrato definitivo. Este chequeo suele ser inmediato pero, en algunos casos, puede llevar días.

//ok
Class ContratoBuilder{
	productor;
	monto;
	clausulas;
	
	setProductor()
	setMonto()
	setClausulas()
	aprobarContrato(){ return new Contrato(productor,monto,clausulas }
}

6)Asimismo, dado que a veces los productores se atrasan mas allá de la fecha de vencimiento del contrato, 
debe ser posible agregarles penalizaciones, que aumenten el saldo de la deuda del contrato.


Class Contrato{
 	productor;
	monto;
	descargas;
	clausulas;
	
	descargaAceptada(descarga){
		monto = monto - descarga.getMontoFinal();
	}
	
	//TODO: Ok lo de la fecha, pero el mismo comentario de antes sobre el efecto
	penalizarProductor(cantidad) { 
	  if(LocalDate.now().compareTo(fechaVencimiento) < 0) 	
		monto += cantidad;
	  else
		throw Exception ("no se paso de la fecha");
	}
}

7)Ver el saldo de un contrato en algún punto del pasado.



Class Contrato{
 	productor;
	monto;
	descargasAceptadas;
	clausulas;
	
	descargaAceptada(descarga){
		monto = monto - descarga.getMontoFinal();
		descargasAceptadas.add(descarga);
	}
	
	penalizarProductor(cantidad) { 
	  if(LocalDate.now().compareTo(fechaVencimiento) < 0) 	
		monto += cantidad;
	  else
		throw Exception ("no se paso de la fecha");
	}

        //TODO, no entiendo que es cantidad. cuantos saca de la lista?
	// ojo que en realidad es monto - this.totalDescargas(fecha) + this.penalizaciones(fecha)
	verMontoPasado(cantidad){
	    //TODO: delegar ese map y sum :D
	   return monto - descargas.getLast(cantidad).mapToDouble(d->d.getMontoFinal()).sum() )
	}	
}
